<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>SHREYAS - Smart City Projects</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root{
            --bg-primary:#0a0e27;
            --bg-secondary:#1a1f3a;
            --bg-card:#252b48;
            --text-primary:#e4e6eb;
            --text-secondary:#b8bcc8;
            --accent:#00d4ff;
            --accent-glow:rgba(0,212,255,0.18);
            --border:rgba(255,255,255,0.06);
            --shadow:rgba(0,0,0,0.5);

            /* SDG button defaults */
            --sdg-bg: rgba(255,255,255,0.04);
            --sdg-border: rgba(255,255,255,0.06);
            --sdg-text: var(--text-primary);
            --sdg-hover: rgba(0,212,255,0.08);
        }
        body.light-mode{
            --bg-primary:#f0f2f5;
            --bg-secondary:#ffffff;
            --bg-card:#ffffff;
            --text-primary:#1c1e21;
            --text-secondary:#606770;
            --accent:#0066ff;
            --accent-glow:rgba(0,102,255,0.12);
            --border:rgba(0,0,0,0.08);
            --shadow:rgba(0,0,0,0.08);

            --sdg-bg: rgba(0,0,0,0.03);
            --sdg-border: rgba(0,0,0,0.06);
            --sdg-text: var(--text-primary);
            --sdg-hover: rgba(0,102,255,0.03);
        }

        *{box-sizing:border-box;margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif}
        html{scroll-behavior:smooth}
        body{background:var(--bg-primary);color:var(--text-primary);line-height:1.6;transition:background .25s,color .25s;overflow-x:hidden}

        .bg-animation{position:fixed;inset:0;z-index:-1;opacity:0.04;background:radial-gradient(circle at 15% 30%,var(--accent) 0%,transparent 40%),radial-gradient(circle at 85% 80%,var(--accent) 0%,transparent 40%);animation:bgPulse 14s ease-in-out infinite}
        @keyframes bgPulse{0%,100%{opacity:0.03}50%{opacity:0.08}}

        .progress-bar{position:fixed;top:0;left:0;height:3px;background:linear-gradient(90deg,var(--accent),#00ffaa);z-index:9999;width:0}

        .theme-toggle{position:fixed;top:18px;right:18px;z-index:1000;background:var(--bg-card);border:1px solid var(--border);padding:8px 14px;border-radius:999px;display:flex;align-items:center;gap:8px;cursor:pointer;box-shadow:0 8px 30px var(--shadow);transition:transform .18s}
        .theme-toggle:hover{transform:scale(1.03)}
        .theme-toggle span{font-weight:700}

        header{background:linear-gradient(135deg,var(--bg-secondary),var(--bg-card));padding:56px 20px;text-align:center;border-bottom:1px solid var(--border);box-shadow:0 8px 40px var(--shadow)}
        header h1{font-size:clamp(24px,4vw,44px);font-weight:800;margin-bottom:10px;background:linear-gradient(90deg,var(--accent),#00ffaa);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}
        header p{color:var(--text-secondary);font-size:clamp(13px,1.6vw,16px)}

        .container{max-width:1200px;margin:36px auto;padding:0 20px 80px}
        .project{background:var(--bg-card);border-radius:14px;padding:28px;margin-bottom:26px;border:1px solid var(--border);box-shadow:0 12px 40px var(--shadow);transition:transform .28s,box-shadow .28s,border-color .28s;opacity:0;animation:slideIn 0.6s ease-out forwards}
        .project:nth-child(1) { animation-delay: 0.08s; }
        .project:nth-child(2) { animation-delay: 0.12s; }
        .project:nth-child(3) { animation-delay: 0.16s; }
        .project:nth-child(4) { animation-delay: 0.20s; }
        .project:nth-child(5) { animation-delay: 0.24s; }
        .project:nth-child(6) { animation-delay: 0.28s; }
        .project:nth-child(7) { animation-delay: 0.32s; }
        .project:nth-child(8) { animation-delay: 0.36s; }
        .project:nth-child(9) { animation-delay: 0.40s; }
        .project:nth-child(10) { animation-delay: 0.44s; }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(24px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .project:hover{transform:translateY(-8px);box-shadow:0 26px 60px var(--accent-glow);border-color:var(--accent)}
        .project h2{color:var(--accent);font-size:clamp(18px,2.6vw,26px);margin-bottom:12px;font-weight:700;display:inline-block}
        .project h2::after{content:'';display:block;height:3px;width:0;background:linear-gradient(90deg,var(--accent),#00ffaa);transition:width .35s}
        .project:hover h2::after{width:100%}

        .project h3{font-size:17px;margin-top:12px;margin-bottom:8px;display:flex;align-items:center;gap:8px;color:var(--text-primary);font-weight:600}
        .project h3::before{content:'‚ñ∏';color:var(--accent)}
        .project p{color:var(--text-secondary);font-size:15px;text-align:justify;line-height:1.75;margin-bottom:12px}

        pre{background:linear-gradient(180deg,rgba(0,0,0,0.35),rgba(0,0,0,0.2));color:var(--text-primary);padding:18px;border-radius:10px;overflow:auto;font-size:13px;border:1px solid var(--border);box-shadow:0 6px 20px rgba(0,0,0,0.25)}
        code{font-family:Consolas,'Courier New',monospace}

        .back-button{display:inline-flex;align-items:center;gap:10px;padding:12px 22px;border-radius:999px;background:linear-gradient(90deg,var(--accent),#00a8cc);color:#00121a;text-decoration:none;font-weight:700;margin:28px 0;box-shadow:0 10px 30px var(--accent-glow)}

        /* SDG button styles (inserted) */
        .sdg-list{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0 18px}
        .sdg-btn{
            display:inline-flex;
            align-items:center;
            gap:8px;
            padding:6px 10px;
            border-radius:999px;
            background:var(--sdg-bg);
            color:var(--sdg-text);
            font-size:13px;
            font-weight:700;
            border:1px solid var(--sdg-border);
            box-shadow:0 6px 18px rgba(0,0,0,0.06);
            cursor:default;               /* not interactive */
            user-select:none;
            transition:transform .12s,background .12s,box-shadow .12s;
        }
        .sdg-btn:hover{background:var(--sdg-hover);transform:translateY(-2px)}
        .sdg-badge{display:inline-grid;place-items:center;width:26px;height:26px;border-radius:50%;font-size:11px;font-weight:800;background:linear-gradient(180deg,var(--accent),#00a8cc);color:#00121a}
        .sdg-label{font-weight:700;color:var(--text-primary);opacity:0.95}
        .sdg-desc{display:block;font-size:12px;color:var(--text-secondary);margin-top:6px}

        footer{text-align:center;padding:36px 18px;color:var(--text-secondary);border-top:1px solid var(--border);margin-top:40px}

        @media (max-width:768px){ header{padding:36px 16px}.project{padding:18px}.container{padding:0 14px} .sdg-list{gap:6px}}
        ::selection{background:var(--accent);color:#001}
    </style>
</head>
<body>
    <div class="bg-animation" aria-hidden="true"></div>
    <div class="progress-bar" id="progressBar"></div>

    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme" type="button">
        <span id="themeIcon">üåô</span>
        <span style="font-size:13px">Theme</span>
    </button>

    <header>
        <h1>Smart City ‚Äì DAA Mini Project Collection</h1>
        <p>Problem Statement ¬∑ Data Structures ¬∑ C++ Algorithm Logic ¬∑ Application Use</p>
    </header>

    <main class="container">
        <!-- 1 -->
        <section class="project" id="proj1">
            <h2>1. Smart Traffic Signal Optimization System</h2>

            <h3>Problem Statement</h3>
            <p>
                Fixed-time traffic lights cause long queues on busy approaches and waste green time on empty roads.
                The system should dynamically adjust signal timings at junctions based on real-time vehicle density
                to minimize total waiting time and congestion.
            </p>

            <!-- SDG buttons: SDG 11, SDG 9, SDG 13 -->
            <div class="sdg-list" aria-hidden="false">
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 9 ‚Äî Industry, Innovation and Infrastructure">
                    <span class="sdg-badge">9</span>
                    <span class="sdg-label">SDG 9</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>// Each junction and its incoming roads
struct Intersection {
    int id;
    std::vector&lt;int&gt; incomingRoadIds;
};

 // Live vehicle count for each road
struct RoadLoad {
    int roadId;
    int vehicleCount;
};

 // intersectionId -&gt; list of (roadId, greenTimeInSeconds)
using SignalPlan = std::unordered_map&lt;int, std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;</code></pre>

            <h3>Application Logic</h3>
            <p>
                Sensors or cameras count vehicles on each incoming road. For every cycle, the controller gathers these
                counts and runs the above logic to compute green time for each approach. The updated signal plan is sent
                to the junction controller, which changes phase durations accordingly, reducing average waiting time and
                improving throughput at busy intersections.
            </p>
        </section>

        <!-- 2 -->
        <section class="project" id="proj2">
            <h2>2. Smart Street Lighting Automation</h2>

            <h3>Problem Statement</h3>
            <p>
                Street lights often remain ON at full power all night, even when no pedestrians or vehicles are present,
                resulting in high energy wastage. The system should automatically control ON/OFF state and brightness
                using ambient light and motion detection.
            </p>

            <!-- SDG buttons: SDG 7, SDG 11, SDG 13 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 7 ‚Äî Affordable and Clean Energy">
                    <span class="sdg-badge">7</span>
                    <span class="sdg-label">SDG 7</span>
                </div>
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct LightPole {
    int id;
    bool isOn;
    int brightness;          // 0 to 100
    std::time_t lastMotion;  // last motion detected time
};</code></pre>

            <h3>Application Logic</h3>
            <p>
                A light sensor determines whether it is night or day. Motion sensors (PIR/IR) near each pole
                trigger updates for that pole. At night, the lamp turns to full brightness when motion is
                detected and then returns to dim mode after a timeout period without motion. During daytime
                all lamps stay OFF. This achieves significant energy savings while retaining safety.
            </p>
        </section>

        <!-- 3 -->
        <section class="project" id="proj3">
            <h2>3. Intelligent Waste Collection &amp; Routing System</h2>

            <h3>Problem Statement</h3>
            <p>
                Garbage trucks follow fixed routes regardless of bin fill levels, causing some bins to overflow
                and others to be collected half-empty. The system should monitor bin fullness and generate efficient
                collection routes only for bins that actually need pickup.
            </p>

            <!-- SDG buttons: SDG 11, SDG 12, SDG 13 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 12 ‚Äî Responsible Consumption and Production">
                    <span class="sdg-badge">12</span>
                    <span class="sdg-label">SDG 12</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct SmartBin {
    int id;
    int node;          // graph node index
    double fillLevel;  // 0.0 ‚Äì 1.0
};</code></pre>

            <h3>Application Logic</h3>
            <p>
                Smart bins periodically send their fill levels to a central server. Bins crossing a configured
                threshold (for example 80%) are marked as "ready for pickup". Using the street graph, the system
                runs Dijkstra to estimate travel distances and greedily chooses the next nearest ready bin,
                generating an ordered route for each truck. This reduces fuel cost, time, and bin overflow.
            </p>
        </section>

        <!-- 4 -->
        <section class="project" id="proj4">
            <h2>4. Citywide Air Quality Monitoring Network</h2>

            <h3>Problem Statement</h3>
            <p>
                Air quality varies across different parts of the city. Without continuous monitoring, it is hard
                to identify pollution hotspots. The system must collect AQI data from distributed sensors, maintain
                a live pollution map, and trigger alerts when safe limits are exceeded.
            </p>

            <!-- SDG buttons: SDG 3, SDG 11, SDG 13 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 3 ‚Äî Good Health and Well-Being">
                    <span class="sdg-badge">3</span>
                    <span class="sdg-label">SDG 3</span>
                </div>
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>// City is represented as a grid of cells (i, j)
using AQGrid = std::vector&lt;std::vector&lt;int&gt;&gt;; // AQI values

struct AQReading {
    int sensorId;
    int gridX, gridY;
    int aqi;
};

struct AQAlert {
    int gridX, gridY;
    int aqi;
    long long timestamp;
};</code></pre>

            <h3>Application Logic</h3>
            <p>
                Each air-quality sensor maps its position to a grid cell and periodically sends AQI values.
                The grid is updated and any cell crossing a critical threshold generates an alert entry.
                A web dashboard can visualise the grid as a heatmap, and authorities can focus on highly
                polluted cells for mitigation like traffic restrictions, green buffers, or industrial checks.
            </p>
        </section>

        <!-- 5 -->
        <section class="project" id="proj5">
            <h2>5. Flood Prediction &amp; Smart Drainage System</h2>

            <h3>Problem Statement</h3>
            <p>
                Low-lying regions in cities face sudden flooding due to heavy rainfall and clogged drains.
                Manual monitoring is slow and reactive. The system must analyse water-level and rainfall data
                to compute flood risk for each zone and trigger early warnings or drainage actions.
            </p>

            <!-- SDG buttons: SDG 11, SDG 13, SDG 6 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
                <div class="sdg-btn" title="SDG 6 ‚Äî Clean Water and Sanitation">
                    <span class="sdg-badge">6</span>
                    <span class="sdg-label">SDG 6</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct ZoneData {
    int zoneId;
    double rainfall;     // recent rainfall in mm
    double waterLevel;   // current water level in cm
    double elevation;    // elevation (higher => safer)
};

double computeRiskScore(const ZoneData &z) {
    double rRain  = z.rainfall;
    double rWater = z.waterLevel;
    double rElev  = std::max(0.0, 100.0 - z.elevation);
    return 0.4 * rRain + 0.4 * rWater + 0.2 * rElev;
}</code></pre>

            <h3>Application Logic</h3>
            <p>
                Rain gauges and water-level sensors feed data into a central controller. Each zone is assigned
                a flood risk score using rainfall, current water level, and elevation. If the risk crosses a
                defined threshold, the zone is marked as "at risk". This can automatically open pumps or sluice
                gates, send alerts to residents, and inform disaster management teams for proactive measures.
            </p>
        </section>

        <!-- 6 -->
        <section class="project" id="proj6">
            <h2>6. Smart Health Kiosk &amp; Telemedicine Booth</h2>

            <h3>Problem Statement</h3>
            <p>
                In remote or crowded urban areas, patients suffer long waiting times and limited doctor access.
                A smart health kiosk should capture vital signs, assign triage priorities, and connect patients
                to remote doctors, ensuring critical cases are treated first.
            </p>

            <!-- SDG buttons: SDG 3, SDG 9 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 3 ‚Äî Good Health and Well-Being">
                    <span class="sdg-badge">3</span>
                    <span class="sdg-label">SDG 3</span>
                </div>
                <div class="sdg-btn" title="SDG 9 ‚Äî Industry, Innovation and Infrastructure">
                    <span class="sdg-badge">9</span>
                    <span class="sdg-label">SDG 9</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct Patient {
    int id;
    std::string name;
    int priority;      // higher = more urgent
    long long arrival; // timestamp
};</code></pre>

            <h3>Application Logic</h3>
            <p>
                The kiosk records vitals such as heart rate, temperature, SpO‚ÇÇ, and basic symptoms. A simple triage
                algorithm assigns a priority score based on abnormal values. Patients are stored in a priority queue,
                and the doctor console always pulls the highest-priority (most critical) patient next. This ensures
                emergency cases receive timely teleconsultation while routine cases wait in order.
            </p>
        </section>

        <!-- 7 -->
        <section class="project" id="proj7">
            <h2>7. Smart Energy Billing &amp; Analytics Platform</h2>

            <h3>Problem Statement</h3>
            <p>
                Traditional billing is based on monthly manual meter readings, which is slow and unable to support
                dynamic tariffs. The system should read smart meters frequently, compute bills using slab-based
                tariffs, and generate analytics on consumption patterns.
            </p>

            <!-- SDG buttons: SDG 7, SDG 9, SDG 11 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 7 ‚Äî Affordable and Clean Energy">
                    <span class="sdg-badge">7</span>
                    <span class="sdg-label">SDG 7</span>
                </div>
                <div class="sdg-btn" title="SDG 9 ‚Äî Industry, Innovation and Infrastructure">
                    <span class="sdg-badge">9</span>
                    <span class="sdg-label">SDG 9</span>
                </div>
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct TariffSlab {
    double unitsLimit;  // max units allowed in this slab
    double rate;        // price per unit
};</code></pre>

            <h3>Application Logic</h3>
            <p>
                Smart meters periodically send energy usage to the backend. The system aggregates units consumed
                in a billing period and applies slab-based tariffs via the above function. Bills are generated,
                stored, and shared with consumers. Over time, the accumulated data can be analysed to detect
                heavy users, peak hours, and opportunities for energy-saving programs or dynamic pricing.
            </p>
        </section>

        <!-- 8 -->
        <section class="project" id="proj8">
            <h2>8. Intelligent Building Fire Safety System</h2>

            <h3>Problem Statement</h3>
            <p>
                In multi-storey smart buildings, fire or smoke in certain corridors can block exits and confuse
                occupants. The system must detect fire-affected nodes and compute safe, shortest evacuation paths
                that avoid hazardous zones.
            </p>

            <!-- SDG buttons: SDG 11, SDG 9, SDG 3 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 9 ‚Äî Industry, Innovation and Infrastructure">
                    <span class="sdg-badge">9</span>
                    <span class="sdg-label">SDG 9</span>
                </div>
                <div class="sdg-btn" title="SDG 3 ‚Äî Good Health and Well-Being">
                    <span class="sdg-badge">3</span>
                    <span class="sdg-label">SDG 3</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>// Dijkstra variant that avoids blocked nodes (sketch)
using BuildingGraph = std::vector&lt;std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;
std::vector&lt;int&gt; dijkstraSafe(int start, const BuildingGraph &g, const std::vector&lt;bool&gt; &blocked, std::vector&lt;int&gt; &parent) {
    // implementation omitted for brevity in this view (see full page source)
    return std::vector&lt;int&gt;();
}</code></pre>

            <h3>Application Logic</h3>
            <p>
                Sensors and detectors mark nodes/corridors as 'blocked' (unsafe) when fire/smoke is detected.
                The pathfinding routine computes shortest safe distances while ignoring blocked nodes.
                Using parent pointers, the system reconstructs evacuation routes and communicates them to building systems.
            </p>
        </section>

        <!-- 9 -->
        <section class="project" id="proj9">
            <h2>9. EV Charging Network with Reservation System</h2>

            <h3>Problem Statement</h3>
            <p>
                EV users often arrive at charging stations to find all chargers occupied. Without proper reservation
                and scheduling, this leads to long waiting times and queue chaos. The system must manage time slots
                for each charging point and handle booking requests without conflict.
            </p>

            <!-- SDG buttons: SDG 7, SDG 11, SDG 13 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 7 ‚Äî Affordable and Clean Energy">
                    <span class="sdg-badge">7</span>
                    <span class="sdg-label">SDG 7</span>
                </div>
                <div class="sdg-btn" title="SDG 11 ‚Äî Sustainable Cities and Communities">
                    <span class="sdg-badge">11</span>
                    <span class="sdg-label">SDG 11</span>
                </div>
                <div class="sdg-btn" title="SDG 13 ‚Äî Climate Action">
                    <span class="sdg-badge">13</span>
                    <span class="sdg-label">SDG 13</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct Slot { long long startTime; long long endTime; };</code></pre>

            <h3>Application Logic</h3>
            <p>
                When a user requests a slot, the server checks for overlaps and either confirms or suggests alternatives.
            </p>
        </section>

        <!-- 10 -->
        <section class="project" id="proj10">
            <h2>10. Smart School Campus Management System</h2>

            <h3>Problem Statement</h3>
            <p>
                Schools handle attendance, classroom allocation, and timetable management manually, which is
                time-consuming and error-prone. The system should centralise student records, automate attendance
                logging, and map each class to suitable classrooms based on capacity.
            </p>

            <!-- SDG buttons: SDG 4, SDG 9 -->
            <div class="sdg-list">
                <div class="sdg-btn" title="SDG 4 ‚Äî Quality Education">
                    <span class="sdg-badge">4</span>
                    <span class="sdg-label">SDG 4</span>
                </div>
                <div class="sdg-btn" title="SDG 9 ‚Äî Industry, Innovation and Infrastructure">
                    <span class="sdg-badge">9</span>
                    <span class="sdg-label">SDG 9</span>
                </div>
            </div>

            <h3>Data Structures &amp; C++ Algorithm Logic</h3>
            <pre><code>struct Student { int id; std::string name; int classId; };</code></pre>

            <h3>Application Logic</h3>
            <p>
                Teachers mark attendance via tablets; the system stores records and allocates classrooms based on size.
            </p>
        </section>

        <div style="text-align:center;margin-top:18px">
            <a class="back-button" href="index.html">‚Üê Back to Home</a>
        </div>
    </main>

    <footer>
        shreyas ¬∑ C++ Algorithmic Design ¬∑ SHREYAS Template
    </footer>

<script>
// theme toggle with persistence
const themeToggle = document.getElementById('themeToggle');
const themeIcon = document.getElementById('themeIcon');
function setTheme(isLight){
    document.body.classList.toggle('light-mode', isLight);
    themeIcon.textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
    localStorage.setItem('shreyas_theme_light', isLight ? '1' : '0');
}
themeToggle.addEventListener('click', ()=> setTheme(!document.body.classList.contains('light-mode')));
// initialize
setTheme(localStorage.getItem('shreyas_theme_light') === '1');

// progress bar
const progressBar = document.getElementById('progressBar');
window.addEventListener('scroll', ()=> {
    const doc = document.documentElement;
    const scrolled = (doc.scrollTop) / (doc.scrollHeight - doc.clientHeight);
    progressBar.style.width = Math.max(0, Math.min(1, scrolled)) * 100 + '%';
});
</script>
</body>
</html>
