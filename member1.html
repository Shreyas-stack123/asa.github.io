<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SHREYAS </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, Helvetica, sans-serif;
        }
        body {
            background: #f5f5f5;
            color: #222;
            line-height: 1.6;
        }
        header {
            background: #111;
            color: #fff;
            padding: 20px 10px;
            text-align: center;
        }
        header h1 {
            font-size: 26px;
            margin-bottom: 5px;
        }
        header p {
            font-size: 14px;
            opacity: 0.8;
        }
        .container {
            max-width: 1100px;
            margin: 20px auto 40px;
            padding: 0 15px;
        }
        .project {
            background: #fff;
            border-radius: 8px;
            padding: 18px 20px;
            margin-bottom: 18px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }
        .project h2 {
            font-size: 20px;
            margin-bottom: 8px;
            color: #1a237e;
        }
        .project h3 {
            font-size: 16px;
            margin-top: 10px;
            margin-bottom: 4px;
            color: #333;
        }
        .project p {
            font-size: 14px;
            margin-bottom: 6px;
            text-align: justify;
        }
        .project ul {
            margin-left: 18px;
            margin-bottom: 6px;
            font-size: 14px;
        }
        pre {
            background: #111;
            color: #eee;
            padding: 10px 12px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            margin: 6px 0 8px;
        }
        code {
            font-family: Consolas, "Courier New", monospace;
        }
        footer {
            text-align: center;
            padding: 15px 10px 30px;
            font-size: 12px;
            color: #555;
        }
    </style>
</head>
<body>

<header>
    <h1>Smart City – DAA Mini Project Collection (C++)</h1>
    <p>Problem Statement · Data Structures · C++ Algorithm Logic · Application Use</p>
</header>

<div class="container">

    <!-- 1. Smart Traffic Signal Optimization System -->
    <section class="project" id="proj1">
        <h2>1. Smart Traffic Signal Optimization System</h2>

        <h3>Problem Statement</h3>
        <p>
            Fixed-time traffic lights cause long queues on busy approaches and waste green time on empty roads.
            The system should dynamically adjust signal timings at junctions based on real-time vehicle density
            to minimize total waiting time and congestion.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>// Each junction and its incoming roads
struct Intersection {
    int id;
    std::vector&lt;int&gt; incomingRoadIds;
};

// Live vehicle count for each road
struct RoadLoad {
    int roadId;
    int vehicleCount;
};

// intersectionId -&gt; list of (roadId, greenTimeInSeconds)
using SignalPlan = std::unordered_map&lt;int, std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;

// trafficMap: roadId -&gt; RoadLoad
void computeSignalPlan(
    const Intersection &inter,
    const std::unordered_map&lt;int, RoadLoad&gt; &trafficMap,
    int cycleTime,
    int minGreen,
    SignalPlan &plan
) {
    int total = 0;
    for (int rid : inter.incomingRoadIds) {
        auto it = trafficMap.find(rid);
        int count = (it == trafficMap.end() ? 1 : std::max(it-&gt;second.vehicleCount, 1));
        total += count;
    }

    std::vector&lt;std::pair&lt;int,int&gt;&gt; phases;
    for (int rid : inter.incomingRoadIds) {
        auto it = trafficMap.find(rid);
        int count = (it == trafficMap.end() ? 1 : std::max(it-&gt;second.vehicleCount, 1));
        double share = (double)count / total;
        int green = std::max(minGreen, (int)(share * cycleTime));
        phases.push_back({rid, green});
    }
    plan[inter.id] = phases;
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Sensors or cameras count vehicles on each incoming road. For every cycle, the controller gathers these
            counts and runs the above logic to compute green time for each approach. The updated signal plan is sent
            to the junction controller, which changes phase durations accordingly, reducing average waiting time and
            improving throughput at busy intersections.
        </p>
    </section>

    <!-- 2. Smart Street Lighting Automation -->
    <section class="project" id="proj2">
        <h2>2. Smart Street Lighting Automation</h2>

        <h3>Problem Statement</h3>
        <p>
            Street lights often remain ON at full power all night, even when no pedestrians or vehicles are present,
            resulting in high energy wastage. The system should automatically control ON/OFF state and brightness
            using ambient light and motion detection.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct LightPole {
    int id;
    bool isOn;
    int brightness;          // 0 to 100
    std::time_t lastMotion;  // last motion detected time
};

// O(1) access for each pole by ID
using PoleMap = std::unordered_map&lt;int, LightPole&gt;;

void updatePoleState(
    LightPole &pole,
    bool isNight,
    bool motionDetected,
    int dimTimeoutSeconds
) {
    std::time_t now = std::time(nullptr);

    if (!isNight) {
        pole.isOn = false;
        pole.brightness = 0;
        return;
    }

    if (motionDetected) {
        pole.lastMotion = now;
        pole.isOn = true;
        pole.brightness = 100;    // full brightness when motion
    } else {
        double diff = std::difftime(now, pole.lastMotion);
        if (diff &gt; dimTimeoutSeconds) {
            pole.isOn = true;
            pole.brightness = 30; // dim mode
        }
    }
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            A light sensor determines whether it is night or day. Motion sensors (PIR/IR) near each pole
            trigger updates for that pole. At night, the lamp turns to full brightness when motion is
            detected and then returns to dim mode after a timeout period without motion. During daytime
            all lamps stay OFF. This achieves significant energy savings while retaining safety.
        </p>
    </section>

    <!-- 3. Intelligent Waste Collection & Routing System -->
    <section class="project" id="proj3">
        <h2>3. Intelligent Waste Collection & Routing System</h2>

        <h3>Problem Statement</h3>
        <p>
            Garbage trucks follow fixed routes regardless of bin fill levels, causing some bins to overflow
            and others to be collected half-empty. The system should monitor bin fullness and generate efficient
            collection routes only for bins that actually need pickup.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct SmartBin {
    int id;
    int node;          // graph node index
    double fillLevel;  // 0.0 – 1.0
};

// adjacency list: graph[u] = list of (v, distance)
using Graph = std::vector&lt;std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;

std::vector&lt;int&gt; dijkstra(int start, const Graph &graph) {
    const int INF = 1e9;
    int n = graph.size();
    std::vector&lt;int&gt; dist(n, INF);
    dist[start] = 0;
    std::priority_queue&lt;std::pair&lt;int,int&gt;,
                        std::vector&lt;std::pair&lt;int,int&gt;&gt;,
                        std::greater&lt;std::pair&lt;int,int&gt;&gt;&gt; pq;
    pq.push({0, start});
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto [v, w] : graph[u]) {
            if (dist[v] &gt; d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}

// Greedy route: always go to nearest unvisited "ready" bin
std::vector&lt;int&gt; planRouteGreedy(
    int depotNode,
    const std::vector&lt;SmartBin&gt; &bins,
    const Graph &graph,
    double fillThreshold
) {
    std::vector&lt;bool&gt; selected(bins.size(), false);
    std::vector&lt;int&gt; route;
    int currentNode = depotNode;

    while (true) {
        int bestIdx = -1;
        int bestDist = 1e9;

        for (int i = 0; i &lt; (int)bins.size(); ++i) {
            if (selected[i] || bins[i].fillLevel &lt; fillThreshold) continue;
            // recompute shortest path from currentNode to bin node
            auto dist = dijkstra(currentNode, graph);
            if (dist[bins[i].node] &lt; bestDist) {
                bestDist = dist[bins[i].node];
                bestIdx = i;
            }
        }

        if (bestIdx == -1) break;
        selected[bestIdx] = true;
        route.push_back(bins[bestIdx].id);
        currentNode = bins[bestIdx].node;
    }
    return route;
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Smart bins periodically send their fill levels to a central server. Bins crossing a configured
            threshold (for example 80%) are marked as “ready for pickup”. Using the street graph, the system
            runs Dijkstra to estimate travel distances and greedily chooses the next nearest ready bin,
            generating an ordered route for each truck. This reduces fuel cost, time, and bin overflow.
        </p>
    </section>

    <!-- 4. Citywide Air Quality Monitoring Network -->
    <section class="project" id="proj4">
        <h2>4. Citywide Air Quality Monitoring Network</h2>

        <h3>Problem Statement</h3>
        <p>
            Air quality varies across different parts of the city. Without continuous monitoring, it is hard
            to identify pollution hotspots. The system must collect AQI data from distributed sensors, maintain
            a live pollution map, and trigger alerts when safe limits are exceeded.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>// City is represented as a grid of cells (i, j)
using AQGrid = std::vector&lt;std::vector&lt;int&gt;&gt;; // AQI values

struct AQReading {
    int sensorId;
    int gridX, gridY;
    int aqi;
};

struct AQAlert {
    int gridX, gridY;
    int aqi;
    long long timestamp;
};

void updateGridAndAlerts(
    AQGrid &grid,
    const std::vector&lt;AQReading&gt; &readings,
    int threshold,
    std::vector&lt;AQAlert&gt; &alerts,
    long long currentTime
) {
    for (const auto &r : readings) {
        grid[r.gridX][r.gridY] = r.aqi;
        if (r.aqi &gt;= threshold) {
            AQAlert a{r.gridX, r.gridY, r.aqi, currentTime};
            alerts.push_back(a);
        }
    }
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Each air-quality sensor maps its position to a grid cell and periodically sends AQI values.
            The grid is updated and any cell crossing a critical threshold generates an alert entry.
            A web dashboard can visualise the grid as a heatmap, and authorities can focus on highly
            polluted cells for mitigation like traffic restrictions, green buffers, or industrial checks.
        </p>
    </section>

    <!-- 5. Flood Prediction & Smart Drainage System -->
    <section class="project" id="proj5">
        <h2>5. Flood Prediction & Smart Drainage System</h2>

        <h3>Problem Statement</h3>
        <p>
            Low-lying regions in cities face sudden flooding due to heavy rainfall and clogged drains.
            Manual monitoring is slow and reactive. The system must analyse water-level and rainfall data
            to compute flood risk for each zone and trigger early warnings or drainage actions.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct ZoneData {
    int zoneId;
    double rainfall;     // recent rainfall in mm
    double waterLevel;   // current water level in cm
    double elevation;    // elevation (higher => safer)
};

double computeRiskScore(const ZoneData &z) {
    double rRain  = z.rainfall;
    double rWater = z.waterLevel;
    double rElev  = std::max(0.0, 100.0 - z.elevation);
    return 0.4 * rRain + 0.4 * rWater + 0.2 * rElev;
}

void evaluateZones(
    const std::vector&lt;ZoneData&gt; &zones,
    double alertThreshold,
    std::vector&lt;std::pair&lt;int,double&gt;&gt; &riskyZones
) {
    for (const auto &z : zones) {
        double score = computeRiskScore(z);
        if (score &gt;= alertThreshold) {
            riskyZones.push_back({z.zoneId, score});
        }
    }
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Rain gauges and water-level sensors feed data into a central controller. Each zone is assigned
            a flood risk score using rainfall, current water level, and elevation. If the risk crosses a
            defined threshold, the zone is marked as “at risk”. This can automatically open pumps or sluice
            gates, send alerts to residents, and inform disaster management teams for proactive measures.
        </p>
    </section>

    <!-- 6. Smart Health Kiosk & Telemedicine Booth -->
    <section class="project" id="proj6">
        <h2>6. Smart Health Kiosk & Telemedicine Booth</h2>

        <h3>Problem Statement</h3>
        <p>
            In remote or crowded urban areas, patients suffer long waiting times and limited doctor access.
            A smart health kiosk should capture vital signs, assign triage priorities, and connect patients
            to remote doctors, ensuring critical cases are treated first.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct Patient {
    int id;
    std::string name;
    int priority;      // higher = more urgent
    long long arrival; // timestamp
};

struct PatientCmp {
    bool operator()(const Patient &a, const Patient &b) const {
        if (a.priority == b.priority)
            return a.arrival &gt; b.arrival; // earlier arrival first
        return a.priority &lt; b.priority;   // max-heap by priority
    }
};

using PatientQueue =
    std::priority_queue&lt;Patient, std::vector&lt;Patient&gt;, PatientCmp&gt;;

void addPatient(PatientQueue &pq, int id, const std::string &name, int priority, long long now) {
    Patient p{id, name, priority, now};
    pq.push(p);
}

Patient getNextPatient(PatientQueue &pq) {
    Patient p = pq.top();
    pq.pop();
    return p;
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            The kiosk records vitals such as heart rate, temperature, SpO₂, and basic symptoms. A simple triage
            algorithm assigns a priority score based on abnormal values. Patients are stored in a priority queue,
            and the doctor console always pulls the highest-priority (most critical) patient next. This ensures
            emergency cases receive timely teleconsultation while routine cases wait in order.
        </p>
    </section>

    <!-- 7. Smart Energy Billing & Analytics Platform -->
    <section class="project" id="proj7">
        <h2>7. Smart Energy Billing & Analytics Platform</h2>

        <h3>Problem Statement</h3>
        <p>
            Traditional billing is based on monthly manual meter readings, which is slow and unable to support
            dynamic tariffs. The system should read smart meters frequently, compute bills using slab-based
            tariffs, and generate analytics on consumption patterns.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct TariffSlab {
    double unitsLimit;  // max units allowed in this slab
    double rate;        // price per unit
};

double computeBill(double units, const std::vector&lt;TariffSlab&gt; &slabs) {
    double cost = 0.0;
    double remaining = units;

    for (size_t i = 0; i &lt; slabs.size() && remaining &gt; 0; ++i) {
        double use = std::min(remaining, slabs[i].unitsLimit);
        cost += use * slabs[i].rate;
        remaining -= use;
    }

    // units beyond last slab charged at last rate
    if (remaining &gt; 0 && !slabs.empty()) {
        cost += remaining * slabs.back().rate;
    }
    return cost;
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Smart meters periodically send energy usage to the backend. The system aggregates units consumed
            in a billing period and applies slab-based tariffs via the above function. Bills are generated,
            stored, and shared with consumers. Over time, the accumulated data can be analysed to detect
            heavy users, peak hours, and opportunities for energy-saving programs or dynamic pricing.
        </p>
    </section>

    <!-- 8. Intelligent Building Fire Safety System -->
    <section class="project" id="proj8">
        <h2>8. Intelligent Building Fire Safety System</h2>

        <h3>Problem Statement</h3>
        <p>
            In multi-storey smart buildings, fire or smoke in certain corridors can block exits and confuse
            occupants. The system must detect fire-affected nodes and compute safe, shortest evacuation paths
            that avoid hazardous zones.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>// Graph representation for building: node = room/corridor/junction
using BuildingGraph = std::vector&lt;std::vector&lt;std::pair&lt;int,int&gt;&gt;&gt;;
// building[u] = list of (v, distance)

std::vector&lt;int&gt; dijkstraSafe(
    int start,
    const BuildingGraph &g,
    const std::vector&lt;bool&gt; &blocked,
    std::vector&lt;int&gt; &parent
) {
    const int INF = 1e9;
    int n = g.size();
    std::vector&lt;int&gt; dist(n, INF);
    parent.assign(n, -1);

    std::priority_queue&lt;std::pair&lt;int,int&gt;,
                        std::vector&lt;std::pair&lt;int,int&gt;&gt;,
                        std::greater&lt;std::pair&lt;int,int&gt;&gt;&gt; pq;

    if (!blocked[start]) {
        dist[start] = 0;
        pq.push({0, start});
    }

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto [v, w] : g[u]) {
            if (blocked[v]) continue;  // avoid fire zones
            if (dist[v] &gt; d + w) {
                dist[v] = d + w;
                parent[v] = u;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            Smoke and temperature sensors mark certain nodes as “blocked” or unsafe. For each occupant location,
            the system runs a modified Dijkstra algorithm that ignores blocked nodes and computes distances to all
            exits. Parent pointers reconstruct the shortest safe path, which can be displayed on evacuation
            screens or used to drive dynamic exit signboards and voice guidance.
        </p>
    </section>

    <!-- 9. EV Charging Network with Reservation System -->
    <section class="project" id="proj9">
        <h2>9. EV Charging Network with Reservation System</h2>

        <h3>Problem Statement</h3>
        <p>
            EV users often arrive at charging stations to find all chargers occupied. Without proper reservation
            and scheduling, this leads to long waiting times and queue chaos. The system must manage time slots
            for each charging point and handle booking requests without conflict.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct Slot {
    long long startTime;  // reserved start (epoch)
    long long endTime;    // reserved end
};

using StationSchedule = std::unordered_map&lt;int, std::vector&lt;Slot&gt;&gt;;
// stationId -&gt; list of reserved slots

bool isFree(
    const std::vector&lt;Slot&gt; &slots,
    long long s,
    long long e
) {
    for (const auto &slot : slots) {
        bool noOverlap = (e &lt;= slot.startTime) || (s &gt;= slot.endTime);
        if (!noOverlap) return false;
    }
    return true;
}

bool reserveSlot(
    StationSchedule &schedule,
    int stationId,
    long long desiredStart,
    long long desiredEnd
) {
    auto &slots = schedule[stationId];
    if (isFree(slots, desiredStart, desiredEnd)) {
        slots.push_back({desiredStart, desiredEnd});
        return true;  // reservation success
    }
    return false;     // conflict with existing
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            When a user wants to book a charging slot, the app sends the desired time range to the server.
            The server checks the station’s schedule to see if this interval overlaps with any existing
            reservations. If free, the new slot is added and the user gets confirmation. Otherwise, the
            system can suggest alternate time ranges or nearby stations with available slots.
        </p>
    </section>

    <!-- 10. Smart School Campus Management System -->
    <section class="project" id="proj10">
        <h2>10. Smart School Campus Management System</h2>

        <h3>Problem Statement</h3>
        <p>
            Schools handle attendance, classroom allocation, and timetable management manually, which is
            time-consuming and error-prone. The system should centralise student records, automate attendance
            logging, and map each class to suitable classrooms based on capacity.
        </p>

        <h3>Data Structures & C++ Algorithm Logic</h3>
        <pre><code>struct Student {
    int id;
    std::string name;
    int classId;
};

struct AttendanceRecord {
    int studentId;
    long long date; // can store as epoch or encoded yyyyMMdd
    bool present;
};

struct ClassRoom {
    int id;
    int capacity;
};

using AttendanceMap =
    std::unordered_map&lt;int, std::vector&lt;AttendanceRecord&gt;&gt;; // studentId -&gt; list

void markAttendance(
    AttendanceMap &attendance,
    int studentId,
    long long date,
    bool present
) {
    attendance[studentId].push_back({studentId, date, present});
}

int allocateClassRoom(
    int classStrength,
    const std::vector&lt;ClassRoom&gt; &rooms
) {
    int chosen = -1;
    int bestCap = INT_MAX;
    for (const auto &r : rooms) {
        if (r.capacity &gt;= classStrength && r.capacity &lt; bestCap) {
            bestCap = r.capacity;
            chosen = r.id;
        }
    }
    return chosen; // -1 if no suitable room
}</code></pre>

        <h3>Application Logic</h3>
        <p>
            When classes start each day, teachers mark attendance through a tablet interface, and records
            are stored in the system. Class strength is calculated from the student list, and the allocation
            function chooses the smallest classroom that can hold that class. This mapping can be used to
            generate a daily timetable, classroom schedule, and attendance reports, simplifying management
            for administrators and teachers.
        </p>
    </section>

</div>

<footer>
    shreyas· C++ Algorithmic Design · Generated Template
</footer>

</body>
</html>

